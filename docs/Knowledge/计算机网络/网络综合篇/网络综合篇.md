### 5.1 键⼊⽹址到⽹⻚显示，期间发⽣了什么？
接下来以下图较简单的⽹络拓扑模型作为例⼦，探究探究其间发⽣了什么？

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173449.png)

#### 孤单⼩弟 —— HTTP
浏览器做的第⼀步⼯作是解析 URL，从⽽⽣成发送给 Web 服务器的请求信息。

让我们看看⼀条⻓⻓的 URL ⾥的各个元素的代表什么，⻅下图：
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173451.png)
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173454.png)
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173457.png)
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173500.png)

所以图中的⻓⻓的 URL 实际上是请求服务器⾥的⽂件资源。


要是上图中的蓝⾊部分 URL 元素都省略了，那应该是请求哪个⽂件呢？

当没有路径名时，就代表访问根⽬录下事先设置的默认⽂件，也就是 /index.html 或者 /default.html 这些⽂件，这样就不会发⽣混乱了

#### ⽣产 HTTP 请求信息

对 URL 进⾏解析之后，浏览器确定了 Web 服务器和⽂件名，接下来就是根据这些信息来⽣成 HTTP 请求消息了。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211220181506.png)
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211220181524.png)

⼀个孤单 HTTP 数据包表示：“我这么⼀个⼩⼩的数据包，没亲没友，直接发到浩瀚的⽹络，谁会知道我呢？谁能载我⼀程呢？谁能保护我呢？我的⽬的地在哪呢？”。充满各种疑问的它，没有停滞不前，依然踏上了征途！

#### 真实地址查询 —— DNS
通过浏览器解析 URL 并⽣成 HTTP 消息后，需要委托操作系统将消息发送给Web服务器。

但在发送之前，还有⼀项⼯作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

⽐如我们打电话的时候，必须要知道对⽅的电话号码，但由于电话号码难以记忆，所以通常我们会将对⽅电话号 +姓名保存在通讯录⾥。


所以，有⼀种服务器就专⻔保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211220182110.png)


域名解析的⼯作流程：
浏览器⾸先看⼀下⾃⼰的缓存⾥有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析⽂件
hosts ，如果还是没有，就会向 DNS 服务器进⾏查询，查询的过程如下：

- 客户端⾸先会发出⼀个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。

- 本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。

- 根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”

- 本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 www.server.com
的 IP 地址吗？”

- 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。

- 本地 DNS 于是转向问权威 DNS 服务器：“⽼三，www.server.com对应的IP是啥呀？” server.com 的权威DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。

- 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。

- 本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。

⾄此，我们完成了 DNS 的解析过程。现在总结⼀下，整个过程我画成了⼀个图。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211220182129.png)


DNS 域名解析的过程蛮有意思的，整个过程就和我们⽇常⽣活中找⼈问路的过程类似，只指路不带路。



数据包表示：“DNS ⽼⼤哥厉害呀，找到了⽬的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”



#### 指南好帮⼿ —— 协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的协议栈。

协议栈的内部分为⼏个部分，分别承担不同的⼯作。上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委托⼯作，下⾯的部分收到委托的⼯作并执⾏。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173508.png)

应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发数据的TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。

协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。


此外 IP 中还包括 ICMP 协议和 ARP 协议。
- ICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息。

- ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址。

IP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线中的信号执⾏发送和接收操作。


数据包看了这份指南表示：“原来我需要那么多⼤佬的协助啊，那我先去找找 TCP ⼤佬！”


#### 可靠传输 —— TCP
HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173511.png)

⾸先，源端⼝号和⽬标端⼝号是不可少的，如果没有这两个端⼝号，数据就不知道应该发给哪个应⽤。

接下来有包的序号，这个是为了解决包乱序的问题。

还有应该有的是确认号，⽬的是确认发出去对⽅是否有收到。如果没有收到就应该 新发送，直到送达，这个是为了解决不丢包的问题。


接下来还有⼀些状态位。例如 SYN 是发起⼀个连接， ACK 是回复， RST 是 新连接， FIN 是结束连接
等。TCP 是⾯向连接的，因⽽双⽅要维护连接的状态，这些带状态位的包的发送，会引起双⽅的状态变更。

还有⼀个 要的就是窗⼝⼤⼩。TCP 要做流量控制，通信双⽅各声明⼀个窗⼝（缓存⼤⼩），标识⾃⼰当前能够的处理能⼒，别发送的太快，撑死我，也别发的太慢，饿死我。

除了做流 控制以外，TCP还会做拥塞控制，对于真正的通路堵⻋不堵⻋，它⽆能为⼒，唯⼀能做的就是控制⾃⼰，也即控制发送的速度。不能改变世界，就改变⾃⼰嘛。

TCP 传输数据之前，要先三次握⼿建⽴连接

如何查看 TCP 的连接状态？

TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173516.png)



TCP 分割数据
如果 HTTP 请求消息⽐较⻓，超过了 MSS 的⻓度，这时 TCP 就需要把 HTTP 的数据拆解成⼀块块的数据发送，⽽不是⼀次性发送所有数据。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173519.png)


- MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节。

- MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度。

数据会被以 MSS 的⻓度为单位进⾏拆分，拆分出来的每⼀块数据都会被放进单独的⽹络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173521.png)


TCP 报⽂⽣成

TCP 协议⾥⾯会有两个端⼝，⼀个是浏览器监听的端⼝（通常是随机⽣成的），⼀个是 Web 服务器监听的端⼝（HTTP 默认端⼝号是 80 ， HTTPS 默认端⼝号是 443 ）

在双⽅建⽴了连接后，TCP 报⽂中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报⽂之后，就需交给下⾯的⽹络层处理。

⾄此，⽹络包的报⽂如下图。


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173524.png)

此时，遇上了 TCP 的数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感⼗⾜啊！有⼤佬可以保护我的可靠送达！但我应该往哪⾛呢？”



#### 远程定位 —— IP
TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象。

我们先看看 IP 报⽂头部的格式：

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173527.png)
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173530.png)

在 IP 协议⾥⾯需要有源地址 IP 和 ⽬标地址 IP：

- 源地址IP，即是客户端输出的 IP 地址；

- ⽬标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06 （⼗六进制），表示协议为 TCP。


假设客户端有多个⽹卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？

当存在多个⽹卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块⽹卡中判断应该使⽤哪个⼀块⽹卡来发送包。

这个时候就需要根据**路由表规则**，来判断哪⼀个⽹卡作为源地址 IP。

在 Linux 操作系统，我们可以使⽤ route -n 命令查看当前系统的路由表。


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173527.png)




![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173530.png)

举个例⼦，根据上⾯的路由表，我们假设 Web 服务器的⽬标地址是 192.168.10.200 。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173533.png)


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173536.png)



- ⾸先先和第⼀条（**⽬的⼦⽹掩码**（ Genmask ）进⾏ 与运算，得到结果为 192.168.10.0 ，但是第⼀个条⽬的Destination 是 192.168.3.0 ，两者不⼀致所以匹配失败。

- 再与第⼆条⽬的⼦⽹掩码进⾏ 与运算，得到的结果为 192.168.10.0 ，与第⼆条⽬的 Destination
192.168.10.0 匹配成功，所以将使⽤ eth1 ⽹卡的 IP 地址作为 IP 包头的源地址。


- 那么假设 Web 服务器的⽬标地址是 10.100.20.100 ，那么依然依照上⾯的路由表规则判断，判断后的结果是和第三条⽬匹配。

第三条⽬⽐较特殊，它⽬标地址和⼦⽹掩码都是 0.0.0.0 ，这表示默认⽹关，如果其他所有条⽬都⽆法匹配，就会⾃动匹配这⼀⾏。并且后续就把包发给路由器， Gateway 即是路由器的 IP 地址。



IP 报⽂⽣成：

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173539.png)



![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173542.png)




此时，加上了 IP 头部的数据包表示 ：“有 IP ⼤佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能⼒！不会害怕在浩瀚的互联⽹迷茫了！可是⽬的地好远啊，我下⼀站应该去哪呢？”



#### 两点传输 —— MAC
⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。

##### MAC 包头格式

MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173546.png)

在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输。

⼀般在 TCP/IP 通信⾥，MAC 包头的协议类型只使⽤：

- 0800 ： IP 协议

- 0806 ： ARP 协议


##### MAC 发送⽅和接收⽅如何确认?

发送⽅的 MAC 地址获取就⽐较简单了，MAC 地址是在⽹卡⽣产时写⼊到 ROM ⾥的，只要将这个值读取出来写⼊到 MAC 头部就可以了。

接收⽅的 MAC 地址就有点复杂了，只要告诉以太⽹对⽅的 MAC 的地址，以太⽹就会帮我们把包发送过去，那么很显然这⾥应该填写对⽅的 MAC 地址。


所以先得搞清楚应该把包发给谁，这个只要查⼀下路由表就知道了。在路由表中找到相匹配的条⽬，然后把包发给Gateway 列中的 IP 地址就可以了。

既然知道要发给谁，按如何获取对⽅的 MAC 地址呢？。

此时就需要 ARP 协议帮我们找到路由器的 MAC 地址。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173548.png)


ARP 协议会在以太⽹中以⼴播的形式，对以太⽹所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有⼈回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

如果对⽅和⾃⼰处于同⼀个⼦⽹中，那么通过上⾯的操作就可以得到对⽅的 MAC 地址。然后，我们将这个 MAC地址写⼊ MAC 头部，MAC 头部就完成了。



好像每次都要⼴播获取，这不是很麻烦吗？

放⼼，在后续操作系统会把本次查询结果放到⼀块叫做 ARP 缓存的内存空间留着以后⽤，不过缓存的时间就⼏分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中的地址。

- ⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询。



##### 查看 ARP 缓存内容

在 Linux 系统中，我们可以使⽤ arp -a 命令来查看 ARP 缓存的内容。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173551.png)

#### MAC 报⽂⽣成
⾄此，⽹络包的报⽂如下图。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173553.png)

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173555.png)

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173558.png)

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173600.png)



此时，加上了 MAC 头部的数据包万分感谢，说道 ：“感谢 MAC ⼤佬，我知道我下⼀步要去哪了！我现在有很多头部兄弟，相信我可以到达最终的⽬的地！”。

带着众多头部兄弟的数据包，终于准备要出⻔了。





#### 出⼝ —— ⽹卡
⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此，我们需要将数字信息转换为电信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程。

负责执⾏这⼀操作的是⽹卡，要控制⽹卡还需要靠⽹卡驱动程序。


⽹卡驱动从 IP 模块获取到包之后，会将其复制到⽹卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上⽤于检测错误的帧校验序列。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173603.png)

- 起始帧分界符是⼀个⽤来表示包起始位置的标记

- 末尾的 FCS （帧校验序列）⽤来检查包传输过程是否有损坏

最后⽹卡会将包转为电信号，通过⽹线发送出去。

唉，真是不容易，发⼀个包，真是历经千⾟万苦。致此，⼀个带有许多头部的数据终于踏上寻找⽬的地的征途了！

#### 送别者 —— 交换机

下⾯来看⼀下包是如何通过交换机的。交换机的设计是将⽹络包原样转发到⽬的地。交换机⼯作在 MAC 层，也称为⼆层⽹络设备。

##### 交换机的包接收操作

⾸先，电信号到达⽹线接⼝，交换机⾥的模块进⾏接收，接下来交换机⾥的模块将电信号转换为数字信号。

然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的⽹卡相同，但交换机的⼯作⽅式和⽹卡不同。


计算机的⽹卡本身具有 MAC 地址，并通过核对收到的包的接收⽅ MAC 地址判断是不是发给⾃⼰的，如果不是发给⾃⼰的则丢弃；相对地，交换机的端⼝不核对接收⽅ MAC 地址，⽽是直接接收所有的包并存放到缓冲区中。因此，和⽹卡不同，交换机的端⼝不具有 MAC 地址。


将包存⼊缓冲区后，接下来需要查询⼀下这个包的接收⽅ MAC 地址是否已经在 MAC 地址表中有记录了。


交换机的 MAC 地址表主要包含两个信息：

- ⼀个是设备的 MAC 地址，

- 另⼀个是该设备连接在交换机的哪个端⼝上。


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173606.png)

举个例⼦，如果收到的包的接收⽅ MAC 地址为 00-02-B3-1C-9C-F9 ，则与图中表中的第 3 ⾏匹配，根据端⼝列的信息，可知这个地址位于 3 号端⼝上，然后就可以通过交换电路将包发送到相应的端⼝了。


所以，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端⼝。


当 MAC 地址表找不到指定的 MAC 地址会怎么样？

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备⼀段时间没有⼯作导致地址被从地址表中删除了。

这种情况下，交换机⽆法判断应该把包转发到哪个端⼝，只能将包转发到除了源端⼝之外的所有端⼝上，⽆论该设备连接在哪个端⼝上都能收到这个包。

有⼈会说：“这样做会发送多余的包，会不会造成⽹络拥塞呢？”


其实完全不⽤过于担⼼，因为发送了包之后⽬标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写⼊ MAC 地址表，下次也就不需要把包发到所有端⼝了。


局域⽹中每秒可以传输上千个包，多出⼀两个包并⽆⼤碍。


此外，如果接收⽅ MAC 地址是⼀个⼴播地址，那么交换机会将包发送到除源端⼝之外的所有端⼝。


以下两个属于⼴播地址：

- MAC 地址中的 FF:FF:FF:FF:FF:FF

- IP 地址中的 255.255.255.255


数据包通过交换机转发抵达了路由器，准备要离开⼟⽣⼟⻓的⼦⽹了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的⼤⻔，我要出远⻔啦！”



#### 出境⼤⻔ —— 路由器

##### 路由器与交换机的区别
⽹络包经过交换机之后，现在到达了路由器，并在此被转发到下⼀个路由器或⽬标设备。

这⼀步转发的⼯作原理和交换机类似，也是通过查表判断包转发的⽬标。

不过在具体的操作过程上，路由器和交换机是有区别的。

- 因为路由器是基于 IP 设计的，俗称三层⽹络设备，路由器的各个端⼝都具有 MAC 地址和 IP 地址；

- ⽽交换机是基于以太⽹设计的，俗称⼆层⽹络设备，交换机的端⼝不具有 MAC 地址。

##### 路由器基本原理

路由器的端⼝具有 MAC 地址，因此它就能够成为以太⽹的发送⽅和接收⽅；同时还具有 IP 地址，从这个意义上来说，它和计算机的⽹卡是⼀样的。

当转发包时，⾸先路由器端⼝会接收发给⾃⼰的以太⽹包，然后路由表查询转发⽬标，再由相应的端⼝作为发送⽅将以太⽹包发送出去。


##### 路由器的包接收操作

⾸先，电信号到达⽹线接⼝部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进⾏错误校验。

如果检查没问题则检查MAC头部中的接收方MAC地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，路由器的端口都具有MAC地址，只接受与自身地址匹配的包，遇到不匹配的包则直接丢弃。

##### 查询路由表确定输出端口

完成包接收操作之后，路由器就会去掉包开头的MAC头部。

MAC头部的作用就是将包送达路由器，其中的接收方MAC地址就是路由器端口的MAC地址。因此，当包到达路由器之后，MAC头部的任务就完成了，于是MAC头部就会被丢弃。

接下来，路由器会根据MAC头部后方的IP头部中的内容进行包的转发操作。

转发操作分为几个阶段，首先是查询路由表判断转发目标。

![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173608.png)

具体的⼯作流程根据上图，举个例⼦。

假设地址为 10.10.1.101 的计算机要向地址为 192.168.1.100 的服务器发送⼀个包，这个包先到达图中的路由器。

判断转发⽬标的第⼀步，就是根据包的接收⽅ IP 地址查询路由表中的⽬标地址栏，以找到相匹配的记录。

路由匹配和前⾯讲的⼀样，每个条⽬的⼦⽹掩码和 192.168.1.100 IP 做 & 与运算后，得到的结果与对应条⽬的⽬标地址进⾏匹配，如果匹配就会作为候选转发⽬标，如果不匹配就继续与下个条⽬进⾏路由匹配。


如第⼆条⽬的⼦⽹掩码 255.255.255.0 与 192.168.1.100 IP 做 & 与运算后，得到结果是 192.168.1.0 ，这与第⼆条⽬的⽬标地址 192.168.1.0 匹配，该第⼆条⽬记录就会被作为转发⽬标。

实在找不到匹配路由时，就会选择默认路由，路由表中⼦⽹掩码为 0.0.0.0 的记录表示「默认路由」。


##### 路由器的发送操作
接下来就会进入包的发送操作。

首先，我们需要根据路由表的网关列判断对方的地址。
- 如果网关是一个IP地址，则这个IP地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。
- 如果网关为空，则IP头部中的接收方IP地址就是要转发到的目标地址，也就是终于找到IP包头里的目标地址了，说明已抵达终点。

知道对方的IP地址之后，接下来需要通过ARP协议根据IP地址查询MAC地址，并将查询的结果作为接收方MAC地址。

路由器也有ARP缓存，因此首先会在ARP缓存中查询，如果找不到则发送ARP查询请求。

接下来是发送方MAC地址字段，这⾥填写输出端⼝的 MAC 地址。还有⼀个以太类型字段，填写 0800 （⼗六进制）表示 IP 协议。

⽹络包完成后，接下来会将其转换成电信号并通过端⼝发送出去。这⼀步的⼯作过程和计算机也是相同的。

发送出去的网络包会通过交换机到达下一个路由器。由于接收⽅ MAC 地址就是下⼀个路由器的地址，所以交换机会根据这⼀地址将包传输到下⼀个路由器。

接下来，下一个路由器会将包转发给下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。


不知你发现了没有，在⽹络包传输的过程中，源 IP 和⽬标 IP 始终是不会变的，⼀直变化的是 MAC 地址，因为需要 MAC 地址在以太⽹内进⾏两个设备之间的包传输。


数据包通过多个路由器道友的帮助，在⽹络世界途经了很多路程，最终抵达了⽬的地的城⻔！城⻔值守的路由器，发现了这个⼩兄弟数据包原来是找城内的⼈，于是它就将数据包送进了城内，再经由城内的交换机帮助下，最终转发到了⽬的地了。数据包感慨万千的说道：“多谢这⼀路上，各路⼤侠的相助！”


#### 互相扒⽪ —— 服务器 与 客户端



![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173611.png)




数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器⾃⼰的MAC 地址符合，符合就将包收起来。

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道⾃⼰上层是 TCP 协议。

于是，扒开 TCP 的头，⾥⾯有序列号，需要看⼀看这个序列包是不是我想要的，如果是就放⼊缓存中然后返回⼀个 ACK，如果不是就丢弃。TCP头部⾥⾯还有端⼝号， HTTP 的服务器正在监听这个端⼝号。

于是，服务器⾃然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问⼀个⻚⾯，于是就把这个⽹⻚封装在HTTP 响应报⽂⾥。

HTTP 响应报⽂也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，⽬的地址是客户端 IP 地址。

穿好头部⾐服后，从⽹卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下⼀个路由器，就这样跳啊跳。

最后跳到了客户端的城⻔把⼿的路由器，路由器扒开 IP 头部发现是要找城内的⼈，于是⼜把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也⾮常的⾼兴，客户能拆快递了！

于是，客户端开始扒⽪，把收到的数据包的⽪扒剩 HTTP 响应报⽂后，交给浏览器去渲染⻚⾯，⼀份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥⼿，⾄此双⽅的连接就断开了。

##### 一个数据包臭不要脸的感受
下⾯内容的 「我」，代表「臭美的数据包⻆⾊」。注：（括号的内容）代表我的吐槽，三连呸！

我⼀开始我虽然孤单、不知所措，但没有停滞不前。我依然满怀信⼼和勇⽓开始了征途。（你当然有勇⽓，你是应⽤层数据，后⾯有底层兄弟当靠⼭，我呸！）

我很庆幸遇到了各路神通⼴⼤的⼤佬，有可靠传输的 TCP、有远程定位功能的 IP、有指明下⼀站位置的 MAC 等（你当然会遇到，因为都被计算机安排好的，我呸！）。

这些⼤佬都给我前⾯加上了头部，使得我能在交换机和路由器的转发下，抵达到了⽬的地！（哎，你也不容易，不吐槽了，放过你！）

这⼀路上的经历，让我认识到了⽹络世界中各路⼤侠协作的 要性，是他们维护了⽹络世界的秩序，感谢他们！（我呸，你应该感谢众多计算机科学家！）


#### 读者问：“请问公⽹服务器的 Mac 地址是在什么时机通过什么⽅式获取到的？我看 arp 获取Mac地址只能获取到内⽹机器的 Mac 地址吧？”

在发送数据包时，如果⽬标主机不是本地局域⽹，填⼊的MAC地址是路由器，也就是把数据包转发给路由器，路由器⼀直转发下⼀个路由器，直到转发到⽬标主机的路由器，发现 IP 地址是⾃⼰局域⽹内的主机，就会 arp 请求获取⽬标主机的 MAC 地址，从⽽转发到这个服务器主机。

转发的过程中，源IP地址和⽬标IP地址是不会变的，源MAC地址和⽬标MAC地址是会变化的。





### 5.2 Linux系统是如何收发网络包的？

#### 网络模型
为了使得多种设备能通过⽹络相互通信，和为了解决各种不同设备在⽹络互联中的兼容性问题，国际标标准化组织制定了开放式系统互联通信参考模型（pen System Interconnection Reference Model），也就是 OSI ⽹络模型。

该模型主要有 7 层，分别是应⽤层、表示层、会话层、传输层、⽹络层、数据链路层以及物理层。

每⼀层负责的职能都不同，如下：

应⽤层，负责给应⽤程序提供统⼀的接⼝；

表示层，负责把数据转换成兼容另⼀个系统能识别的格式；

会话层，负责建⽴、管理和终⽌表示层实体之间的通信会话；

传输层，负责端到端的数据传输；

⽹络层，负责数据的路由、转发、分⽚；

数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；

物理层，负责在物理⽹络中传输数据帧；

由于OSI模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。事实上，我们比较常见也比较实用的是，即TCP/IP网络模型，Linux系统正是按照这套网络模型来实现网络协议栈的。

TCP/IP网络模型共有4层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：

- 应用层，负责向用户提供一组应用程序，比如HTTP\DNS\FTP等；

- 传输层，负责端到端的通信，比如TCP\UDP等；

- 网络层，负责网络包的封装、分片、路由、转发，比如IP、ICMP等；

- 网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、MAC寻址、差错检测，以及通过网卡传输网络帧等；

TCP/IP网络模型相比OSI网络模型简化了不少，它们之间的关系如下图：


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173613.png)


不过，我们常说的七层和四层负载均衡，是用OSI网络模型来描述的，七层对应的是应用层，四层对应的是传输层。


#### Linux网络协议栈

我们可以把自己的身体比作应用层中的数据，打底衣服比作传输层中的TCP头，外套比作网络层中IP头，帽子和鞋子分别比作网络接口层的帧头和帧尾。


在冬天这个季节，当我们要从家⾥出去玩的时候，⾃然要先穿个打底⾐服，再套上保暖外套，最后穿上帽⼦和鞋⼦才出⻔，这个过程就好像我们把 TCP 协议通信的⽹络包发出去的时候，会把应⽤层的数据按照⽹络协议栈层层封
装和处理。


你从下面这张图可以看到，应用层数据在每一层的封装格式。


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173616.png)


其中：
- 传输层，给应用数据前面增加了TCP头；
- 网络层，给TCP数据包前面增加了IP头；
- 网络接口层，给IP数据包前后分别增加了帧头和帧尾；

这些新增和头部和尾部，都有各自的作用，也都是按照特定的协议格式填充，这每一层都增加了各自的协议头,那自然网络包的大小就增加了，但物理链路并不能传输任意大小的数据包，所以在以太网中，规定了最大传输单元（MTU）是1500字节，也就是规定了单次传输的最大IP包大小。

当⽹络包超过 MTU 的⼤⼩，就会在⽹络层分⽚，以确保分⽚后的 IP 包不会超过 MTU ⼤⼩，如果 MTU 越⼩，需要的分包就越多，那么⽹络吞吐能⼒就越差，相反的，如果 MTU 越⼤，需要的分包就越少，那么⽹络吞吐能⼒就
越好。


知道了 TCP/IP ⽹络模型，以及⽹络包的封装原理后，那么 Linux ⽹络协议栈的样⼦，你想必猜到了⼤概，它其实就类似于 TCP/IP 的四层结构：


![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173620.png)




![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173624.png)



![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173628.png)




从上面的网络协议栈，你可以看到：
- 应用程序需要通过系统调用，来跟Socket层进行数据交互；

- Socket层的下面就是传输层、网络层和网络接口层；

- 最下面的一层，则是网卡驱动程序和硬件网卡设备；

#### Linux 接收网络包的流程

网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个数据包后，会通过DMA技术，将网络包放入到Ring Buffer，这是一个环形缓冲区。

那接收到⽹络包后，应该怎么告诉操作系统这个⽹络包已经到达了呢？

最简单的⼀种⽅式就是触发中断，也就是每当⽹卡收到⼀个⽹络包，就触发⼀个中断告诉操作系统。

但是，这存在⼀个问题，在⾼性能⽹络场景下，⽹络包的数 会⾮常多，那么就会触发⾮常多的中断，要知道当CPU 收到了中断，就会停下⼿⾥的事情，⽽去处理这些⽹络包，处理完毕后，才会回去继续其他事情，那么频繁
地触发中断，则会导致 CPU ⼀直没玩没了的处理中断，⽽导致其他任务可能⽆法继续前进，从⽽影响系统的整体效率。


所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引⼊了 NAPI 机制，它是混合「中断和轮询」的⽅式来接收⽹络包，它的核⼼概念就是**不采⽤中断的⽅式读取数据**，⽽是⾸先采⽤中断唤醒数据接收的服务程序，然后 poll 的⽅法来轮询数据。

⽐如，当有⽹络包到达时，⽹卡发起硬件中断，于是会执⾏⽹卡硬件中断处理函数，中断处理函数处理完需要「暂时屏蔽中断」，然后唤醒「软中断」来轮询处理数据，直到没有新数据时才恢复中断，这样⼀次中断处理多个⽹络包，于是就可以降低⽹卡中断带来的性能开销。


那软中断是怎么处理⽹络包的呢？它会从 Ring Buffer 中拷⻉数据到内核 struct sk_buff 缓冲区中，从⽽可以作为⼀
个⽹络包交给⽹络协议栈进⾏逐层处理。

⾸先，会先进⼊到⽹络接⼝层，在这⼀层会检查报⽂的合法性，如果不合法则丢弃，合法则会找出该⽹络包的上层协议的类型，⽐如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给⽹络层。

到了⽹络层，则取出 IP 包，判断⽹络包下⼀步的⾛向，⽐如是交给上层处理还是转发出去。当确认这个⽹络包要发送给本机后，就会从 IP 头⾥看看上⼀层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。

传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端⼝、⽬的 IP、⽬的端⼝」 作为标识，找出对应的Socket，并把数据拷⻉到 Socket 的接收缓冲区。

最后，应⽤层程序调⽤ Socket 接⼝，从内核的 Socket 接收缓冲区读取新到来的数据到应⽤层。

⾄此，⼀个⽹络包的接收过程就已经结束了，你也可以从下图左边部分看到⽹络包接收的流程，右边部分刚好反过来，它是⽹络包发送的流程。





![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20211216173631.png)




#### Linux发送网络包的流程
如上图的右半部分，发送网络包的流程正好和接收流程相反。

首先，应用程序会调用Socket发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的Socket层，Socket层会将应用层数据拷贝到Socket发送缓冲区中。


接下来，网络协议从Socket发送缓冲区中取出数据包，并按照TCP/IP协议栈从上到下层逐层处理。

如果使用的是TCP传输协议发送数据，那么会在传输层增加TCP包头，然后交给网络层，网络层会给数据包增加IP包，然后通过查询路由表确认下一跳IP，并按照MTU大小进行分片。

分片后的网络包，就会被送到网络接口层，在这里会通过ARP协议获得下一跳的MAX地址，然后增加帧头和帧尾，放到发包队列中。

这一些准备好后，会触发软中断告诉网卡驱动程序，这里有新的网络包需要发送，最后驱动程序通过DMA，从发包队列中读取网络包，将其放入到硬件网卡的队列中，随后物理网卡再将它发送出去。


### 5.3我们的⼀个 Web 服务运久之后，就⽆法与客户端正常建⽴连接了?

1.使⽤ tcpdump 抓包发现 TCP 三次握⼿过程中，服务端把客户端握⼿过程中最后 1 个 ack 给丢掉了。

2.执⾏ netstat -s 命令查看 TCP error 相关的信息，发现 TCP 全连接队列溢出了。

3.接着再通过 ss -lnt 命令进⼀步确认，当前 TCP 全连接队列确实超过了 TCP 全连接队列最⼤值，这个问题就很快定位出来了。


另外，当 TCP 全连接队列溢出后，由于tcp_abort_on_overflow 内核参数默认为 0，所以服务端会丢掉客户端发过来的 ack，如果你把该参数设置为 1，那现象将变成，服务端会给客户端发送 RST 报⽂，废弃掉连接。

那要扩⼤全连接队列也不难，TCP 全连接队列最⼤值取决于 somaxconn 和 backlog 之间的最⼩值，也就是min(somaxconn,backlog) ，其中 somaxconn 是内核参数，⽽backlog 是我们程序 listen ⽅法中指定的参数。

上⾯这个⼩例⼦，很明显是⽆法通过看应⽤层的代码来解决的，必须了解 TCP 的机制，才能找到解决之道。



















