### 1、一条SQL语句引发的思考
![](https://cdn.jsdelivr.net/gh/Gpslypy/mediaImage01@master/img202111/QQ图片20220101171608.png)

创建了一张数据库表，表里的字段只有主键索引（id）和联合索引（a，b，c），然后执行 select * from t where c = 0; 这条语句发现走的是索引，困惑有两点：

- 第一点，where c 这个条件并不符合联合索引的最左匹配原则，怎么就查询的时候走了索引呢？

- 第二点，在这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？

tips：最左匹配原则？

这个数据库表创建了（a，b，c）这个联合索引，要能使其生效必须保证 where 条件里最左边是 a 字段，比如以下这几种情况：

where a = 0;

where a = 0 and b = 0;

where a = 0 and c = 0;

where a = 0 and b = 0 and c = 0;

where a = 0 and c = 0 and b = 0;


而如果 where 条件里最左边的字段不是 a 时，就无法使用到联合索引，比如以下这种情况，就是不符合最左匹配规则：

where b = 0;

where c = 0;

where b = 0 and c =0;

where c = 0 and b = 0;


知道了联合索引的最左匹配原则后，再来看看第一个问题。

为什么  select * from t where c = 0; 这条不符合联合索引的最左匹配原则的查询语句走了索引查询呢？



首先，这张表的字段没有「非索引」字段，所以 select * 相当于 select id,a,b,c，然后这个查询的内容和条件 都在联合索引树里，因为联合索引树的叶子节点包含「索引列+主键」，所以查联合索引树就能查到全部结果了，这个就是覆盖索引。


但是执行计划里的 type 是 index，这代表着是通过全扫描联合索引树的方式查询到数据的，这是因为 where c 并不符合联合索引最左匹配原则。


那么，如果写了个符合最左原则的 select 语句，那么 type 就是 ref，这个效率就比 index 全扫描要高一些。


那为什么选择全扫描联合索引树，而不扫描全表（聚集索引树）呢？

因为联合索引树的记录比要小的多，而且这个 select * 不用执行回表操作，所以直接遍历联合索引树要比遍历聚集索引树要小的多，因此 MySQL 选择了全扫描联合索引树。



为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？

因为加了其他字段后，select * from t where c = 0; 查询的内容就不能在联合索引树里找到了，而且条件也不符合最左匹配原则，这样既不能覆盖索引也不能执行回表操作，所以这时只能通过扫描全表来查询到所有的数据。


cookies:
- 覆盖索引：我们把这种索引中已经包含所有需要读取的列的查询方式称为**覆盖索引。**


- 联合索引指的是索引组织的类型；

- 覆盖索引可以看作是联合索引的最优解，某种意义上可以看成包含的列“最全“。








